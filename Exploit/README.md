# The SecDev Challenge


Attack preconditions:
-----------------------
+ Since this tool is not an exploit but rather a simple C2Server/C2Client tool that can be used to take control of 
          the target computer, it can virtually run on any computer (the penetration process should install python 
          v3.5 if it's not yet installed and then add the client script as a scheduled task or integrate it into 
          another script that is already scheduled on the target computer)


Attack action - The general idea:
---------------------------------
In order for this servers to remain as stealth as possible the following security measurements are taken:
+ The client will attempt to find the hostname of this server via a simple DGA algorithm that will use a
          combination and selection of words from a long list. The words will be selected and concatenated depending
          on the current date. If the server manager will generate new domain names according to the algorithm then the
          algorithm should allow the server manager to move from server to server without having to change and re-distribute
          the clients.
  
+ The server will listen on two ports (defaults to 8080 and 8081). On one port the server will respond to HTTP
          requests for retrieval of the next command that the client need to execute and for the update of its result.
          The second port will be used for key negotiation according to the Diffie-Hellman algorithm in stateful TCP. Every time the client
          is invoked, the client will first try to access the second port and select a secret session key (cannot be deduced
          from the information that is being sent or received). To make this communication harder to detect by the network
          security teams, the information that is being sent in the TCP communication conforms to the HTTP standard and
          also contains a valid HTML body so that it would look very similar to HTTP traffic (although it's a stateful
          connection and not stateless like normal HTTP). Once the secret key is generated on both sides, the client will
          connect via HTTP to the first port to get the next command to execute. Almost every information that is being
          sent and received via the HTTP port will be encrypted by the AES algorithm that will use the 256bit key that
          was generated in the previous phase.
  
+ The client and the server will attempt to select an encryption key by using the Diffie-Hellman algorithm like
          metioned above but if for some reason this process is unsuccessful they will communicate in clear-text.
          
+ To make the communication less alarming and more "normal" some bits of random data were added to the communication
  in the urls and other items.
  
+ The client and server will send and receive messages by modifying the value of a cookie (in the TCP communication
          it will just look like a cookie in the communication although of course it's not a real cookie) so that the transactions
          will look more normal.


Attack postconditions:
------------------------
+ If this tool is running successfully on the target machine then adding new commands to the list of commands for a given 
          client would cause this client to run the given command and return its output to the C2Server.


P.S:
------
##Alternatives that came to mind:
+ To use DNS tunnelling for communication with the C2Server - I decided not to use it because
          TCP DNS queries would stand out and UDP DNS queries are limited in their size and might not
          be able to hold all the data that was returned from the various commands that can be ran from the C2Server.
          
+ To use cloud storage (e.g. GoogleDrive, OneDrive, Dropbox, etc.) - I decided not to use this option since I believe
          that in most cases such communication will be blocked in many financial organization.
          
+ To use HTTP/S for communication with the C2Server - I decided to use this option but added a "twist" of my own.
          The client uses HTTP (could just as well be HTTPS if I had purchased a certificate) to get the commands that
          need to be run and to report back the commands' output but I also added another connection that is used for
          generating an AES encryption key (using the Diffie-Hellman algorithm) by which the data that is being sent
          and received is encrypted regardless of whether it's an HTTP or HTTPS connection. The connection that is
          being used for generating the key is a stateful TCP connection that looks like an HTTP connection to remain
          more stealth.


##Things that can be done to improve this tool:
+ Encryption of the report that is being sent to the C2Server - For some reason I couldn't encrypt the
          commands' result in the report that is being sent to the C2Server and still be able to decrypt it correctly on
          the server side. (I think it has something to do
          with the combination of encryption and encoding of the result and perhaps also with the encoding of
          cookies/post parameters that is being done "under the hood" by the MechanicalSoup and Bottle frameworks). I guess
          that if I'll work a bit harder on this I'll find the problem and fix it but I believe that for the purpose of
          this demo the current status will do just fine.
  
+ Save the client ID somewhere on the client and use the same client id in every request. That will surely make it
          easier for the C2Server manager to find all the results that came from the same PC. The client id can be saved
          either on the registry or in a file somewhere on the client. I think it's pretty easy to do so I haven't done it
          yet.
  
+ Add support for more channels to contact the C2Server such as DNS tunnelling, cloud storage, etc. that will be
         used as a backup channel.